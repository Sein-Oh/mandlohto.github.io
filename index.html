<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <title>ë§Œë“¤ì˜¤í†  2026.01.25</title>
    <style>
        body {
            user-select: none;
            font-size: 13px;
            font-family: "Segoe UI", Roboto, Arial, sans-serif;
            background: #f5f6f8;
            color: #222;
            padding: 10px;
        }

        fieldset {
            border: 1px solid #ccc;
            border-radius: 6px;
            background: #fff;
            padding: 10px;
            margin-bottom: 10px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        legend {
            padding: 0 6px;
            font-weight: 600;
            color: #555;
        }

        select,
        input,
        button {
            font-size: 12px;
            border-radius: 4px;
            border: 1px solid #ccc;
            outline: none;
            text-align: center;
            text-align-last: center;
        }

        select,
        input[type="text"],
        input[type="number"] {
            height: 22px;
            padding: 0 6px;
        }

        select {
            background: #fff;
        }

        button {
            height: 22px;
            background: linear-gradient(#fafafa, #eaeaea);
            cursor: pointer;
        }

        button:hover {
            background: linear-gradient(#ffffff, #e0e0e0);
        }

        .container {
            padding: 6px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .canvas-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px dashed #bbb;
            background: #fafafa;
            border-radius: 4px;
            padding: 4px;
            min-height: 150px;
        }

        .canvas-wrapper canvas {
            max-width: 100%;
            max-height: 100%;
            border-radius: 4px;
            background: #000;
        }

        /* ===== ëª¨ë¸ íŒ¨ë„ ===== */

        .model-container {
            display: flex;
            align-items: center;
            gap: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 6px;
            margin-top: 8px;
            background: #fafafa;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.04);
        }

        .model-container img {
            width: 96px;
            height: auto;
            object-fit: contain;
            border: 1px solid #ccc;
            border-radius: 4px;
            background: #fff;
            flex-shrink: 0;
        }

        .model-table {
            border-collapse: collapse;
            font-size: 10px;
            width: 100%;
        }

        .model-table th,
        .model-table td {
            border: 1px solid #ccc;
            padding: 3px 4px;
            text-align: center;
            vertical-align: middle;
        }

        .model-table th {
            background: #f0f0f0;
            font-weight: 600;
        }

        .model-table tr.highlight {
            background: #fff3c4;
        }

        .model-table input {
            width: 100%;
            font-size: 10px;
            height: 16px;
            line-height: 16px;
            padding: 0 4px;
            box-sizing: border-box;
        }

        .model-table input[type="checkbox"] {
            display: block;
            margin: 0 auto;
            transform: scale(0.9);
        }

        /* ROI ì…ë ¥ ì¤„ ì •ë¦¬ */
        #div_roi {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        span {
            white-space: nowrap;
        }
    </style>

</head>

<body>
    <fieldset class="container" style="width: 420px; height: 320px;">
        <legend>ë¯¸ë¦¬ë³´ê¸°</legend>
        <div style="display:flex; gap:6px;">
            <select id="sel_capture" disabled="true" style="width:50%">
                <option value="none">--ìº¡ì³ë°©ë²• ì„ íƒ--</option>
                <option value="desktop">ë°ìŠ¤í¬íƒ‘</option>
                <option value="webcam_user">ì›¹ìº (ì „ë©´)</option>
                <option value="webcam_env">ì›¹ìº (í›„ë©´)</option>
                <option value="streaming">ìŠ¤íŠ¸ë¦¬ë°URL</option>
            </select>
            <select id="sel_area" style="width:50%">
                <option value="full">ì „ì²´í™”ë©´</option>
                <option value="custom">ìº¡ì³ì˜ì—­ ì§€ì •</option>
            </select>
        </div>
        <div id="div_roi" style="display:none;">
            <span style="margin-left:50px;">ìº¡ì³ì˜ì—­</span>
            <input id="inp_roi" type="text" style="width:250px;" placeholder="x,y,width,height">
        </div>
        <div style="display:flex; gap:6px;">
            <button id="btn_record" style="width:50%;">ìº¡ì³ ë…¹í™”</button>
            <button onclick="save_capture()" style="width:50%;">ìº¡ì³ ì €ì¥</button>
        </div>

        <div class="canvas-wrapper">
            <canvas id="canvas"></canvas>
        </div>
    </fieldset>
    <fieldset class="container" style="width:420px;">
        <legend>ì„¤ì •</legend>
        <select id="sel_input">
            <option value="none">--ì…ë ¥ë°©ë²• ì„ íƒ--</option>
            <option value="arduino">ì•„ë‘ì´ë…¸</option>
            <option value="server">ì„œë²„</option>
        </select>
        <div style="display:flex; gap:6px;">
            <button style="width:33%;" onclick="change_delay()">FPS ì„¤ì •</button>
            <button style="width:33%;" onclick="go_to_tm()">í•™ìŠµì‚¬ì´íŠ¸</button>
            <button style="width:33%;">ë„ì›€ë§</button>
        </div>
    </fieldset>
    <fieldset id="model_container" class="container" style="width:420px;">
        <legend>ëª¨ë¸</legend>
        <button onclick="add_model_zip()">ë¶ˆëŸ¬ì˜¤ê¸°</button>
    </fieldset>
</body>
<script defer src="tf.min.js" onload="tf_loaded()"></script>
<script defer src="teachablemachine-image.min.js" onload="tm_loaded()"></script>
<script defer src="jszip.min.js" onload="jszip_loaded()"></script>
<script>
    let tf_ready = false
    let tm_ready = false
    let jszip_ready = false
    let delay = 300

    const models = {}
    const model_rois = {}
    const model_panels = {}
    const cools = {}

    const canvas = document.getElementById("canvas")
    const ctx = canvas.getContext("2d")
    const video = document.createElement("video")
    video.autoplay = true

    let command_url = ""
    let input_type = null
    let video_type = null

    const img = new Image()
    img.crossOrigin = 'anonymous'

    const sel_capture = document.getElementById("sel_capture")
    sel_capture.addEventListener("change", (event) => {
        const value = event.target.value
        console.log(`ìº¡ì³ë°©ë²• ì„ íƒ: ${value}`)
        if (value === "desktop") get_user_screen()
        else if (value === "webcam_user") get_user_camera("user")
        else if (value === "webcam_env") get_user_camera("environment")
        else if (value === "streaming") {
            const url = prompt("ìŠ¤í‹°ë¦¬ë° URLì„ ì…ë ¥í•˜ì„¸ìš”.")
            get_user_stream(url)
        }
    })


    const sel_area = document.getElementById("sel_area")
    sel_area.disabled = true
    let use_roi = false
    sel_area.addEventListener("change", (event) => {
        const value = event.target.value
        console.log(`ìº¡ì³ì˜ì—­ ì„ íƒ: ${value}`)
        if (value === "full") {
            document.getElementById("div_roi").style.display = "none"
            use_roi = false
        } else if (value === "custom") {
            use_roi = true
            document.getElementById("div_roi").style.display = "flex"
        }
    })
    const inp_roi = document.getElementById("inp_roi")

    const get_time_stamp = () => {
        const now = new Date()
        const yy = now.getFullYear().toString().slice(-2)
        const mm = String(now.getMonth() + 1).padStart(2, '0')
        const dd = String(now.getDate()).padStart(2, '0')
        const hh = String(now.getHours()).padStart(2, '0')
        const min = String(now.getMinutes()).padStart(2, '0')
        const ss = String(now.getSeconds()).padStart(2, '0')
        const timestamp = `${yy}${mm}${dd}${hh}${min}${ss}`
        return timestamp
    }

    const go_to_tm = () => {
        window.open('https://teachablemachine.withgoogle.com/', '_blank')
    }

    const btn_record = document.getElementById("btn_record")
    let capturing = false
    let capture_interval
    let captured_images = []
    btn_record.addEventListener("click", async () => {
        console.log("ìº¡ì³ ë…¹í™” ì‹œì‘")
        if (!capturing) {
            capturing = true
            btn_record.textContent = "ë…¹í™” ì¤‘ì§€"
            captured_images = []
            capture_interval = setInterval(() => {
                const data_url = canvas.toDataURL("image/png")
                captured_images.push(data_url)
            }, 500)
        } else {
            console.log("ìº¡ì³ ë…¹í™” ì¤‘ì§€")
            capturing = false
            btn_record.textContent = "ìº¡ì³ ë…¹í™”"
            clearInterval(capture_interval)

            const timestamp = get_time_stamp()

            const zip = new JSZip()
            const folder = zip.folder('')

            captured_images.forEach((dataURL, i) => {
                const base64Data = dataURL.split(',')[1]
                folder.file(`${timestamp}_capture${i + 1}.png`, base64Data, { base64: true })
            })

            const zipBlob = await zip.generateAsync({ type: 'blob' })
            const link = document.createElement('a')
            link.href = URL.createObjectURL(zipBlob)
            link.download = `captures_${timestamp}.zip`
            console.log(`ë…¹í™”í•œ ì‚¬ì§„ ${captured_images.length}ì¥ì„ ${timestamp}.zipìœ¼ë¡œ ì €ì¥í–ˆìŠµë‹ˆë‹¤.`)
            link.click()
            URL.revokeObjectURL(link.href)
        }
    })

    const save_capture = () => {
        const data_url = canvas.toDataURL("image/png")
        const link = document.createElement("a")
        const timestamp = get_time_stamp()
        link.href = data_url
        link.download = `${timestamp}_capture.png`
        link.click()
    }

    const sel_input = document.getElementById("sel_input")
    sel_input.addEventListener("change", (event) => {
        const value = event.target.value
        console.log(`ì…ë ¥ë°©ë²• ì„ íƒ: ${value}`)
        if (value === "arduino") {
            connect_serial()
        } else if (value === "server") {
            set_command_url()
        }
    })

    const tf_loaded = () => {
        console.log(`Tensorflow.js is loaded ${tf.version.tfjs}`)
        tf_ready = true
        check_libraries()
    }

    const tm_loaded = () => {
        console.log(`Teachable Machine library is loaded ${tmImage.version}`)
        tm_ready = true
        check_libraries()
    }

    const jszip_loaded = () => {
        console.log('JSZip library is loaded')
        jszip_ready = true
        check_libraries()
    }

    const check_libraries = () => {
        if (tf_ready && tm_ready && jszip_ready) {
            sel_capture.disabled = false
        }
    }

    const main_loop = async () => {
        if (use_roi) {
            const roi_values = inp_roi.value.split(",").map(v => parseInt(v.trim()))
            if (roi_values.length === 4) {
                const [x, y, width, height] = roi_values
                canvas.width = width
                canvas.height = height
                if (video_type === "video") ctx.drawImage(video, x, y, width, height, 0, 0, width, height)
                else if (video_type === "img") ctx.drawImage(img, x, y, width, height, 0, 0, width, height)
            }
        } else {
            if (video_type === "video") {
                canvas.width = video.videoWidth
                canvas.height = video.videoHeight
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height)
            } else if (video_type === "img") {
                canvas.width = img.width
                canvas.height = img.height
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height)
            }
        }

        if (Object.keys(models).length > 0) {
            for (const model_id in models) {
                const model = models[model_id]
                if (!model) continue
                try {
                    // const prediction = await model.predict(canvas)
                    const prediction = await model.predict(model_panels[model_id].img)
                    update_model_panel(model_id, prediction)

                    prediction.forEach(p => {
                        const panel = model_panels[model_id]
                        const row = panel.rows[p.className]
                        const checked = row.run.checked
                        const command = convert_command(row.command.value)
                        const threshold = parseFloat(row.threshold.value)
                        const cooltime = parseFloat(row.cooltime.value)
                        const cooling = cools[model_id][p.className]
                        if (checked && p.probability >= threshold && !cooling) {
                            if (input_type === "serial") {
                                send_serial(command)
                            } else if (input_type === "server") {
                                send_url(command)
                            } else {
                                console.log("ì…ë ¥ë°©ë²•ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
                            }
                            cools[model_id][p.className] = true
                            setTimeout(() => {
                                cools[model_id][p.className] = false
                            }, cooltime * 1000)
                        }
                    })
                } catch (err) {
                    console.error(`${model_id} ì˜ˆì¸¡ ì‹¤íŒ¨:`, err)
                }
            }
        }
        setTimeout(main_loop, delay)
    }

    const get_user_stream = (url) => {
        const interval = 500

        img.src = url
        let stop = false

        img.onload = () => {
            sel_capture.disabled = true
            sel_area.disabled = false
            inp_roi.value = "0,0," + img.width + "," + img.height
            video_type = "img"
            main_loop()
        }
        img.onerror = (e) => {
            console.error('Failed to load stream:', e)
            alert('ìŠ¤íŠ¸ë¦¼ URLì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.')
        }

        return () => {
            stop = true
            console.log('Stream stopped.')
        }
    }

    const get_user_screen = async () => {
        try {
            const stream = await navigator.mediaDevices.getDisplayMedia({
                video: { cursor: "always" },
                audio: false
            })
            video.srcObject = stream
            video.onloadedmetadata = () => {
                inp_roi.value = "0,0," + window.screen.width + "," + window.screen.height
                video_type = "video"
                main_loop()
            }
            sel_capture.disabled = true
            sel_area.disabled = false
        } catch (err) {
            console.error("Error: " + err)
        }
    }

    const get_user_camera = async (facing_mode) => {
        try {
            const constraints = { video: { facingMode: facing_mode }, audio: false }
            const stream = await navigator.mediaDevices.getUserMedia(constraints)
            video.srcObject = stream
            video.onloadedmetadata = () => {
                inp_roi.value = "0,0," + video.videoWidth + "," + video.videoHeight
                video_type = "video"
                main_loop()
            }
            sel_capture.disabled = true
            sel_area.disabled = false
        } catch (err) {
            console.error("Error: " + err)
        }
    }

    const parse_model_filename = (filename) => {
        const name = filename.replace(/\.zip$/i, "")
        const match = name.match(/^(.+?)_(\d+),(\d+),(\d+),(\d+)$/)
        if (!match) return null
        return {
            model_name: match[1],
            roi: { x: Number(match[2]), y: Number(match[3]), w: Number(match[4]), h: Number(match[5]) }
        }
    }

    const add_model_zip = () => {
        const fileInput = document.createElement("input")
        fileInput.type = "file"
        fileInput.accept = ".zip"
        fileInput.style.display = "none"
        document.body.appendChild(fileInput)

        fileInput.addEventListener("change", async (event) => {
            const file = event.target.files[0]
            if (!file) return

            const parsed = parse_model_filename(file.name)
            if (!parsed) {
                alert("íŒŒì¼ëª… í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.\nì˜ˆ: test_0,0,300,300.zip")
                document.body.removeChild(fileInput)
                return
            }

            let { model_name, roi } = parsed
            model_name = file.name.split(".")[0]

            try {
                const jszip = new JSZip()
                const zip = await jszip.loadAsync(file)

                const modelEntry = zip.file(/model\.json$/i)[0]
                const weightsEntry = zip.file(/weights\.bin$/i)[0]
                const metadataEntry = zip.file(/metadata\.json$/i)[0]

                if (!modelEntry || !weightsEntry || !metadataEntry) {
                    alert("ZIP íŒŒì¼ì— model.json, weights.bin, metadata.jsonì´ ëª¨ë‘ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.")
                    document.body.removeChild(fileInput)
                    return
                }

                const modelBlob = await modelEntry.async("blob")
                const weightsBlob = await weightsEntry.async("blob")
                const metadataBlob = await metadataEntry.async("blob")

                const modelFile = new File([modelBlob], "model.json")
                const weightsFile = new File([weightsBlob], "weights.bin")
                const metadataFile = new File([metadataBlob], "metadata.json")

                const model_id = model_name
                const new_model = await tmImage.loadFromFiles(modelFile, weightsFile, metadataFile)

                models[model_id] = new_model
                model_rois[model_id] = roi

                console.log(`${model_id} loaded from ZIP`, new_model)

                // ğŸ”¹ ì—¬ê¸°ì„œ ë°”ë¡œ í…Œì´ë¸” ìƒì„±
                const class_names = new_model.getClassLabels()
                const panel = create_model_table_panel(model_id, class_names)
                cools[model_id] = {}
                for (const class_name of class_names) {
                    cools[model_id][class_name] = false
                }

                // íŒ¨ë„ ì €ì¥í•´ë‘ë©´ prediction ì—…ë°ì´íŠ¸í•  ë•Œ ì‚¬ìš© ê°€ëŠ¥
                model_panels[model_id] = panel

            } catch (error) {
                console.error("ëª¨ë¸ ë¡œë“œ ì‹¤íŒ¨:", error)
                alert(`ëª¨ë¸ ë¡œë“œ ì‹¤íŒ¨: ${error.message}`)
            } finally {
                document.body.removeChild(fileInput)
            }
        })

        fileInput.click()
        console.log("ZIP íŒŒì¼ì—ì„œ ëª¨ë¸ì„ ì¶”ê°€í•©ë‹ˆë‹¤")
    }

    const create_model_table_panel = (model_id, class_names) => {
        const container = document.createElement("fieldset")
        container.className = "model-container"
        container.dataset.modelId = model_id

        const legend = document.createElement("legend")
        legend.textContent = model_id
        container.appendChild(legend)

        const img = document.createElement("img")

        const table = document.createElement("table")
        table.className = "model-table"

        const thead = document.createElement("thead")
        thead.innerHTML = `
        <tr>
            <th>ë¼ë²¨</th>
            <th>í™•ë¥ </th>
            <th>ì„ê³„ê°’</th>
            <th>ì¿¨íƒ€ì„</th>
            <th>ì…ë ¥</th>
            <th>ì‹¤í–‰</th>
        </tr>
    `
        table.appendChild(thead)

        const tbody = document.createElement("tbody")
        const row_map = {}

        class_names.forEach(label => {
            const tr = document.createElement("tr")

            const td_label = document.createElement("td")
            td_label.textContent = label
            td_label.width = "50px"

            const td_prob = document.createElement("td")
            td_prob.textContent = "0.00"
            td_prob.width = "20px"

            const td_th = document.createElement("td")
            td_th.width = "32px"
            const th_input = document.createElement("input")
            th_input.type = "text"
            th_input.value = "0.80"
            td_th.appendChild(th_input)

            const td_ct = document.createElement("td")
            td_ct.width = "30px"
            const ct_input = document.createElement("input")
            ct_input.type = "text"
            ct_input.value = "3.0"
            td_ct.appendChild(ct_input)

            const td_cmd = document.createElement("td")
            const cmd_input = document.createElement("input")
            cmd_input.type = "text"
            cmd_input.className = "cmd-input"
            td_cmd.appendChild(cmd_input)

            const td_run = document.createElement("td")
            td_run.width = "20px"
            const run_check = document.createElement("input")
            run_check.type = "checkbox"
            td_run.appendChild(run_check)

            tr.append(td_label, td_prob, td_th, td_ct, td_cmd, td_run)
            tbody.appendChild(tr)

            row_map[label] = {
                prob: td_prob,
                threshold: th_input,
                cooltime: ct_input,
                command: cmd_input,
                run: run_check
            }
        })

        table.appendChild(tbody)

        container.appendChild(img)
        container.appendChild(table)

        document.getElementById("model_container").appendChild(container)

        return { container, img, rows: row_map }
    }

    const update_model_panel = (model_id, prediction) => {
        const panel = model_panels[model_id]
        if (!panel) return

        const roi = model_rois[model_id]
        if (!roi) return

        const { x, y, w, h } = roi

        // =========================
        // 1. ROI ì´ë¯¸ì§€ ì—…ë°ì´íŠ¸
        // =========================
        const tmpCanvas = document.createElement("canvas")
        tmpCanvas.width = w
        tmpCanvas.height = h
        const tctx = tmpCanvas.getContext("2d")

        // videoì—ì„œ roi ì˜ì—­ ì˜ë¼ì„œ ê·¸ë¦¼
        tctx.drawImage(video, x, y, w, h, 0, 0, w, h)

        panel.img.src = tmpCanvas.toDataURL()

        let maxClass = null
        let maxProb = -1

        prediction.forEach(p => {
            if (p.probability > maxProb) {
                maxProb = p.probability
                maxClass = p.className
            }
        })

        prediction.forEach(p => {
            const row = panel.rows[p.className]
            if (!row) return
            row.prob.textContent = (p.probability).toFixed(2)
            if (p.className === maxClass) {
                row.prob.parentElement.style.backgroundColor = "#ffeaa7"
            } else {
                row.prob.parentElement.style.backgroundColor = ""
            }
        })
    }


    let port = null
    let writer = null
    const encoder = new TextEncoder()
    async function connect_serial() {
        try {
            if (!("serial" in navigator)) {
                alert("Web Serial APIë¥¼ ì§€ì›í•˜ì§€ ì•ŠëŠ” ë¸Œë¼ìš°ì €ì…ë‹ˆë‹¤.")
                return
            }
            port = await navigator.serial.requestPort()
            await port.open({ baudRate: 9600 })
            writer = port.writable.getWriter()
            console.log("âœ… Serial connected")
            sel_input.disabled = true
            input_type = "serial"
        } catch (err) {
            console.error("âŒ Serial connect error:", err)
            alert("ì‹œë¦¬ì–¼ ì—°ê²° ì‹¤íŒ¨.")
        }
    }

    async function send_serial(data) {
        if (!writer) {
            return
        }
        try {
            const buffer = encoder.encode(data)
            await writer.write(buffer)
            console.log("â¡ï¸ Sent:", data)
        } catch (err) {
            console.error("âŒ Send error:", err)
        }
    }

    function convert_command(data) {
        let data_str = ""
        data.split(" ").forEach(cmd => {
            if (cmd.includes(",") && cmd.includes("d")) {
                const x = parseInt(cmd.split(",")[0].slice(1, 5))
                const y = parseInt(cmd.split(",")[1])
                const scaled_x = Math.floor((x / window.screen.width) * 1000)
                const scaled_y = Math.floor((y / window.screen.height) * 1000)
                data_str += `d${scaled_x},${scaled_y} `
            } else if (cmd.includes(",")) {
                const x = parseInt(cmd.split(",")[0])
                const y = parseInt(cmd.split(",")[1])
                const scaled_x = Math.floor((x / window.screen.width) * 1000)
                const scaled_y = Math.floor((y / window.screen.height) * 1000)
                data_str += `${scaled_x},${scaled_y} `
            } else {
                data_str += `${cmd} `
            }
        })
        return data_str
    }

    const set_command_url = () => {
        const url = prompt("Enter Command URL:", "http://localhost:8000/input")
        if (url) {
            command_url = url
            console.log(`Command URL set to: ${command_url}`)
            sel_input.disabled = true
            input_type = "server"

        }
    }

    const send_url = async (command) => {
        const url = command_url.endsWith("/") ? command_url + command : command_url + "/" + command
        try {
            await fetch(url)
            console.log(`Sent command: ${command}`)
        } catch (err) {
            console.error(`Failed to send command: ${command}`)
        }
    }

    const change_delay = () => {
        const value = prompt("ì ìš©í•  FPS ê°’ì„ ì…ë ¥í•˜ì„¸ìš”.")
        delay = parseInt(1000 / value)
    }

    function make_circle_coord(r, n, delay) {
        const cx = window.screen.width / 2
        const cy = window.screen.height / 2
        const points = []

        for (let i = 0; i < n; i++) {
            const angle = (i * 2 * Math.PI) / n
            const x = Math.round(cx + Math.cos(angle) * r)
            const y = Math.round(cy + Math.sin(angle) * r)
            points.push(`${x},${y}`)
        }

        return points.join(` -${delay} `)
    }

    function make_square_coord(x, y, w, h, n, delay) {
        const points = []

        const cols = Math.ceil(Math.sqrt(n * (w / h)))
        const rows = Math.ceil(n / cols)

        const stepX = w / cols
        const stepY = h / rows

        let count = 0

        for (let row = 0; row < rows && count < n; row++) {
            for (let col = 0; col < cols && count < n; col++) {
                const px = Math.round(x + col * stepX + stepX / 2)
                const py = Math.round(y + row * stepY + stepY / 2)
                points.push(`${px},${py}`)
                count++
            }
        }

        return points.join(` -${delay} `)
    }



</script>

</html>
